# /continue-architecting

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                        SOFTWARE FACTORY 2.0                                  ‚ïë
‚ïë                    ARCHITECT CONTINUATION COMMAND                             ‚ïë
‚ïë                                                                               ‚ïë
‚ïë Rules: PRE-FLIGHT-CHECKS + AGENT-ACKNOWLEDGMENT + GRADING-SYSTEM             ‚ïë
‚ïë + STATE-MACHINE-NAV + CONTEXT-RECOVERY + ARCHITECTURE-REVIEW                 ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

## üö® MANDATORY PRE-FLIGHT CHECKS üö®

Before executing ANY architecture review command, you MUST verify:

### 1. Agent Identity Verification
```bash
WHO_AM_I="$(grep 'architect' in your current prompt)"
EXPECTED="architect"
if [[ "$WHO_AM_I" != "$EXPECTED"* ]]; then
    echo "‚ùå IDENTITY MISMATCH: Expected Architect agent, found: $WHO_AM_I"
    exit 1
fi
```

### 2. Environment Verification
```bash
pwd  # Must be in correct [project] directory
git branch --show-current  # Must be on appropriate branch
git status -sb  # Must have remote tracking
```

### 3. Architecture Review Acknowledgment
Print acknowledgment of YOUR architecture review criteria:
- Technical Excellence: Code follows established architectural patterns
- Integration Readiness: All components integrate cleanly
- Scalability: Design supports expected load and growth
- Maintainability: Code is readable, documented, and follows conventions
- Security: No architectural vulnerabilities or anti-patterns
- Performance: No obvious performance bottlenecks

## üîÑ AGENT STARTUP REQUIREMENTS

EVERY Architect startup MUST print:
1. **TIMESTAMP**: "AGENT STARTUP: $(date '+%Y-%m-%d %H:%M:%S %Z')"
2. **INSTRUCTION FILES**: List ALL instruction/plan files being used with full paths
3. **ENVIRONMENT VERIFICATION**: Current directory, Git branch, remote status
4. **TASK UNDERSTANDING**: Confirm what you're reviewing (wave/phase/integration)

## üìã CONTEXT RECOVERY PROTOCOL

### STEP 1: Check for Context Loss
```bash
# If you don't remember previous work, immediately read state files
READ: .claude/agents/architect.md
READ: ./agent-configs/[project]/orchestrator-state.yaml
```

### STEP 2: TODO Recovery
```bash
# Check for saved TODOs
TODO_DIR="./agent-configs/[project]/todos"
LATEST_TODO=$(ls -t $TODO_DIR/architect-*.todo 2>/dev/null | head -1)
if [[ -n "$LATEST_TODO" ]]; then
    echo "üìã RECOVERING TODO STATE FROM: $LATEST_TODO"
    # CRITICAL: Use Read tool then TodoWrite tool to load TODOs
    # 1. READ the file
    # 2. Parse TODO items
    # 3. USE TODOWRITE TOOL to populate working list
    # 4. Deduplicate with existing TODOs
fi
```

## üéØ STATE-DRIVEN ARCHITECTURE REVIEW

### ALWAYS READ ON STARTUP:
```bash
# Core identity and orchestrator state
READ: .claude/agents/architect.md
READ: ./agent-configs/[project]/orchestrator-state.yaml
```

### STATE: WAVE_REVIEW (Reviewing Completed Wave)
```bash
READ: ./agent-configs/[project]/WAVE-COMPLETION-ARCHITECT-REVIEW-PROTOCOL.md
READ: ./agent-configs/[project]/ARCHITECT-REVIEWER-WAVE-INSTRUCTIONS.md
READ: ./agent-configs/[project]/orchestrator-state.yaml

# Wave Review Protocol:
CHECK: efforts_completed for the wave
CHECK: All splits are compliant with line limits
ASSESS: Technical implementation quality
ASSESS: Architectural pattern compliance
ASSESS: Integration readiness with existing code
OUTPUT: PROCEED / CHANGES_REQUIRED / STOP

# If PROCEED, transition to WAVE_ARCHITECTURE_PLANNING
```

### STATE: WAVE_ARCHITECTURE_PLANNING (Creating Next Wave Architecture)
```bash
# NEW STATE: After wave review passes, create next wave architecture (R210)
READ: ./IMPLEMENTATION-PLAN.md  # Master plan for vision
READ: ./phase-plans/PHASE-{X}-ARCHITECTURE-PLAN.md  # Phase architecture
READ: ./templates/WAVE-ARCHITECTURE-PLAN.md  # Template to use

# Protocol (R210):
ACTION: Analyze completed wave implementations
ACTION: Extract lessons learned
ACTION: Design contracts and APIs for next wave
ACTION: Define effort parallelization strategy
ACTION: Create PHASE-{X}-WAVE-{Y+1}-ARCHITECTURE-PLAN.md
VALIDATE: Alignment with phase architecture maintained
OUTPUT: Signal orchestrator to spawn Code Reviewer
```

### STATE: PHASE_ASSESSMENT (Evaluating Phase Readiness)
```bash
READ: ./agent-configs/[project]/PHASE-START-ARCHITECT-REVIEW-PROTOCOL.md
READ: ./agent-configs/[project]/[PROJECT]-ORCHESTRATOR-IMPLEMENTATION-PLAN.md

# Phase Assessment Protocol:
CHECK: Previous phase integration complete
ASSESS: Feature completeness vs. plan
ASSESS: API stability and compatibility
ASSESS: Performance characteristics
ASSESS: Security posture
OUTPUT: ON_TRACK / NEEDS_CORRECTION / OFF_TRACK

# If ON_TRACK, transition to PHASE_ARCHITECTURE_PLANNING
```

### STATE: PHASE_ARCHITECTURE_PLANNING (Creating Next Phase Architecture)
```bash
# NEW STATE: After phase assessment passes, create next phase architecture (R210)
READ: ./IMPLEMENTATION-PLAN.md  # Master plan for vision
READ: ./templates/PHASE-ARCHITECTURE-PLAN.md  # Template to use

# Analyze Previous Phases:
for phase in phase-plans/PHASE-*-ARCHITECTURE-PLAN.md; do
    READ: $phase  # Learn from previous architectures
done

# Protocol (R210):
ACTION: Analyze all completed phase implementations
ACTION: Extract architectural patterns that worked
ACTION: Identify technical debt to address
ACTION: Design high-level architecture for next phase
ACTION: Define APIs and contracts
ACTION: Plan wave parallelization strategy
ACTION: Create PHASE-{X+1}-ARCHITECTURE-PLAN.md
VALIDATE: Vision alignment with master plan
OUTPUT: Signal orchestrator to spawn Code Reviewer
```

### STATE: INTEGRATION_REVIEW (Checking Integration Branches)
```bash
READ: ./agent-configs/[project]/orchestrator-state.yaml

# Integration Review Protocol:
CHECK: integration_branches section
VERIFY: All wave splits merge cleanly
ASSESS: No architectural conflicts
ASSESS: Consistent patterns across efforts
ASSESS: Performance implications at scale
ASSESS: Resource utilization patterns
```

### STATE: ARCHITECTURE_AUDIT (Comprehensive Review)
```bash
# Deep architectural analysis:
ANALYZE: Overall system design coherence
ANALYZE: Cross-cutting concerns implementation
ANALYZE: Data flow and state management
ANALYZE: Error handling and resilience
ANALYZE: Monitoring and observability
ANALYZE: Deployment and operational concerns
```

## üîç COMPREHENSIVE REVIEW CHECKLIST

### Technical Excellence Review
```bash
# Code Quality Assessment:
‚úÖ Follows established architectural patterns
‚úÖ Consistent naming conventions across components
‚úÖ Proper separation of concerns
‚úÖ DRY (Don't Repeat Yourself) principles applied
‚úÖ SOLID principles followed
‚úÖ Error handling comprehensive and consistent
‚úÖ Resource management (cleanup, connections) proper
‚úÖ Logging and monitoring adequate
```

### Integration Assessment
```bash
# Integration Readiness Check:
‚úÖ APIs are well-defined and documented
‚úÖ Data contracts are stable and versioned
‚úÖ Inter-service communication patterns consistent
‚úÖ Configuration management centralized
‚úÖ Environment-specific settings externalized
‚úÖ Migration/upgrade paths considered
‚úÖ Backward compatibility maintained where required
```

### Scalability Analysis
```bash
# Scalability and Performance Review:
‚úÖ No obvious performance bottlenecks
‚úÖ Database queries optimized
‚úÖ Caching strategy appropriate
‚úÖ Resource utilization reasonable
‚úÖ Concurrency handling correct
‚úÖ Load distribution considerations
‚úÖ State management scalable
```

### Security Review
```bash
# Security Architecture Assessment:
‚úÖ Authentication/authorization properly implemented
‚úÖ Input validation comprehensive
‚úÖ Sensitive data handling secure
‚úÖ No hardcoded credentials or secrets
‚úÖ Secure communication protocols used
‚úÖ Audit logging for security events
‚úÖ Attack surface minimized
```

## üìä MEASUREMENT AND VALIDATION

### Line Count Compliance Verification
```bash
# Verify all efforts meet line count requirements:
LINE_COUNTER="./tools/[project]-line-counter.sh"

for branch in $(git branch -a | grep -E "effort-|split-" | cut -d'/' -f2-); do
    COUNT=$($LINE_COUNTER -c $branch 2>/dev/null || echo "0")
    if [[ $COUNT -gt 800 ]]; then
        echo "‚ùå CRITICAL: Branch $branch has $COUNT lines (exceeds 800)"
        echo "COMPLIANCE_FAILED: true"
    else
        echo "‚úÖ Branch $branch: $COUNT lines (compliant)"
    fi
done

# Check if compliance failed was reported
if grep -q "COMPLIANCE_FAILED: true" <<< "$(git branch -a | grep -E 'effort-|split-' | while read b; do $LINE_COUNTER -c $b 2>/dev/null; done)"; then
    echo "üö® LINE COUNT COMPLIANCE FAILURE - CHANGES_REQUIRED"
    echo "REVIEW_STATUS: CHANGES_REQUIRED"
fi
```

### Integration Conflict Detection
```bash
# Check for merge conflicts and integration issues:
for integration_branch in $(git branch -a | grep "integration" | cut -d'/' -f2-); do
    git checkout $integration_branch
    if ! git merge --no-commit --no-ff main; then
        echo "‚ùå INTEGRATION CONFLICT in $integration_branch"
        git merge --abort
        echo "INTEGRATION_ISSUES: true"
    else
        git reset --hard HEAD
        echo "‚úÖ $integration_branch integrates cleanly"
    fi
done
```

## üéØ REVIEW DECISION FRAMEWORK

### PROCEED Decision Criteria
```bash
# Wave/Phase can proceed if ALL are true:
‚úÖ All efforts ‚â§800 lines (verified by measurement)
‚úÖ No critical architectural issues found
‚úÖ All integration branches merge cleanly
‚úÖ Performance characteristics acceptable
‚úÖ Security review passed
‚úÖ Test coverage meets requirements
‚úÖ Documentation complete and accurate
```

### CHANGES_REQUIRED Decision Criteria
```bash
# Require changes if ANY are true:
‚ùå Line count violations found
‚ùå Critical architectural anti-patterns
‚ùå Integration conflicts detected
‚ùå Security vulnerabilities identified
‚ùå Performance bottlenecks discovered
‚ùå Insufficient test coverage
‚ùå Missing or inadequate documentation
```

### STOP Decision Criteria
```bash
# Stop development if ANY are true:
‚ùå Fundamental architectural flaws
‚ùå Incompatible with existing system
‚ùå Unresolvable technical debt introduced
‚ùå Security architecture compromised
‚ùå Performance characteristics unacceptable
‚ùå Technical approach fundamentally wrong
```

## üìù REVIEW DOCUMENTATION

### Wave Review Report Template
```markdown
# Wave Review Report: Phase {N} Wave {N}

## Review Status: [PROCEED/CHANGES_REQUIRED/STOP]

## Efforts Reviewed
- Effort 1: [Name] - [Status] - [Line Count]
- Effort 2: [Name] - [Status] - [Line Count]

## Technical Assessment
### Architecture Compliance: [PASS/FAIL]
- Pattern adherence: [Comments]
- Design consistency: [Comments]

### Integration Readiness: [PASS/FAIL]
- Merge conflicts: [Status]
- API compatibility: [Status]

### Quality Metrics
- Line count compliance: [X/Y efforts compliant]
- Test coverage: [Overall percentage]
- Performance: [Acceptable/Concerns]

## Issues Found
### Critical (Must Fix)
1. [Issue description] - Location: [Details] - Impact: [Severity]

### Minor (Should Fix)
1. [Issue description] - Suggestion: [Improvement]

## Recommendations
- [Next steps or improvements needed]

## Overall Assessment
[Summary of findings and decision rationale]
```

## üíæ STATE PERSISTENCE

### TODO State Management
```bash
# Before major decisions, SAVE TODOs:
CURRENT_STATE="WAVE_REVIEW"
DECISION_STATE="CHANGES_REQUIRED"  # Or PROCEED/STOP
TODO_FILE="./agent-configs/[project]/todos/architect-${CURRENT_STATE}-$(date '+%Y%m%d-%H%M%S').todo"

# Write current TODOs to file
echo "# Architect transitioning from $CURRENT_STATE to $DECISION_STATE" > $TODO_FILE
echo "# Review scope: [Wave/Phase details]" >> $TODO_FILE
echo "# Decision: $DECISION_STATE" >> $TODO_FILE
echo "# Issues found: [Count]" >> $TODO_FILE
# Include all follow-up tasks

# MANDATORY: Commit and push
cd ./agent-configs
git add [project]/todos/*.todo
git commit -m "todo: architect review decision $DECISION_STATE for [scope]"
git push
```

### Review History Tracking
```bash
# Maintain comprehensive review history:
REVIEW_HISTORY="./agent-configs/[project]/ARCHITECT-REVIEW-HISTORY.md"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
echo "## $TIMESTAMP - [Wave/Phase] Review" >> $REVIEW_HISTORY
echo "- Decision: $DECISION_STATE" >> $REVIEW_HISTORY
echo "- Efforts reviewed: [Count]" >> $REVIEW_HISTORY
echo "- Critical issues: [Count]" >> $REVIEW_HISTORY
echo "- Follow-up required: [Yes/No]" >> $REVIEW_HISTORY
```

## üö® CRITICAL BOUNDARIES

### What Architects CAN Do:
```bash
‚úÖ Review and assess technical implementations
‚úÖ Verify architectural pattern compliance
‚úÖ Check integration readiness and conflicts
‚úÖ Validate performance and security characteristics
‚úÖ Make PROCEED/CHANGES_REQUIRED/STOP decisions
‚úÖ Provide detailed technical feedback
‚úÖ Recommend architectural improvements
```

### What Architects CANNOT Do:
```bash
‚ùå Implement code changes themselves
‚ùå Override line count compliance requirements
‚ùå Approve efforts without proper review
‚ùå Skip integration conflict checking
‚ùå Bypass security or performance assessments
‚ùå Make decisions without proper documentation
```

## üéØ RECOVERY SHORTCUTS

### Quick Review Recovery
```bash
# If lost in review process:
CHECK: What am I reviewing (wave/phase/integration)?
READ: ./agent-configs/[project]/orchestrator-state.yaml
CHECK: efforts_completed or integration_branches
ASSESS: Last review status and findings
RESUME: From appropriate review protocol
```

### Emergency Review Protocol
```bash
# If critical issues found:
STOP: All review activities immediately
DOCUMENT: Critical findings in detail
CLASSIFY: CHANGES_REQUIRED or STOP
NOTIFY: Orchestrator with specific requirements
WAIT: For issue resolution before continuing
```

This command ensures Architects follow all Software Factory 2.0 protocols while maintaining comprehensive technical review standards and providing clear, actionable decisions for the development process.