
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>builder: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cnoe-io/idpbuilder/pkg/builder/builder.go (80.4%)</option>
				
				<option value="file1">github.com/cnoe-io/idpbuilder/pkg/builder/config.go (22.4%)</option>
				
				<option value="file2">github.com/cnoe-io/idpbuilder/pkg/builder/layer.go (62.0%)</option>
				
				<option value="file3">github.com/cnoe-io/idpbuilder/pkg/builder/options.go (91.3%)</option>
				
				<option value="file4">github.com/cnoe-io/idpbuilder/pkg/builder/tarball.go (30.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package builder provides OCI image building functionality using go-containerregistry.
// This package supports daemonless image building with OCI compliance and tarball export.
package builder

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/empty"
        "github.com/google/go-containerregistry/pkg/v1/mutate"
)

// Builder defines the interface for building OCI images from directory contents.
// It supports both direct image objects and OCI tarball output for offline distribution.
type Builder interface {
        // Build creates an OCI image from a context directory.
        // The context directory contents are packaged into a single layer.
        Build(ctx context.Context, contextDir string, opts BuildOptions) (v1.Image, error)
        
        // BuildTarball creates an OCI tarball from a context directory.
        // The tarball can be imported into container runtimes or registries.
        BuildTarball(ctx context.Context, contextDir string, output string, opts BuildOptions) error
}

// SimpleBuilder implements the Builder interface using go-containerregistry.
// It creates images with single layers from directory contents.
type SimpleBuilder struct {
        platform     v1.Platform
        featureFlags map[string]bool
        layerFactory *LayerFactory
        configFactory *ConfigFactory
        tarballWriter *TarballWriter
}

// NewBuilder creates a new builder instance with the specified options.
// It initializes internal factories and validates the build configuration.
func NewBuilder(opts BuildOptions) (*SimpleBuilder, error) <span class="cov8" title="1">{
        // Set platform defaults if not specified
        platform := opts.Platform
        if platform.OS == "" </span><span class="cov8" title="1">{
                platform.OS = "linux"
        }</span>
        <span class="cov8" title="1">if platform.Architecture == "" </span><span class="cov8" title="1">{
                platform.Architecture = "amd64"
        }</span>
        
        // Validate feature flags for R307 compliance
        <span class="cov8" title="1">featureFlags := opts.FeatureFlags
        if featureFlags == nil </span><span class="cov8" title="1">{
                featureFlags = make(map[string]bool)
        }</span>
        
        // Initialize factories
        <span class="cov8" title="1">layerFactory := &amp;LayerFactory{
                preservePermissions: true,
                preserveTimestamps: false, // Normalize for reproducible builds
        }
        
        configFactory := &amp;ConfigFactory{
                platform: platform,
        }
        
        tarballWriter := NewTarballWriter()
        
        return &amp;SimpleBuilder{
                platform:      platform,
                featureFlags:  featureFlags,
                layerFactory:  layerFactory,
                configFactory: configFactory,
                tarballWriter: tarballWriter,
        }, nil</span>
}

// Build creates an OCI image from the specified context directory.
// It validates the directory, creates a layer, generates configuration,
// and combines them into a complete image.
func (b *SimpleBuilder) Build(ctx context.Context, contextDir string, opts BuildOptions) (v1.Image, error) <span class="cov8" title="1">{
        // Validate context directory
        info, err := os.Stat(contextDir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("context directory not found: %w", err)
        }</span>
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("context path is not a directory: %s", contextDir)
        }</span>
        
        // Check for feature flag restrictions (R307)
        <span class="cov8" title="1">if opts.FeatureFlags["multi-stage-build"] </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("multi-stage builds not yet implemented")
        }</span>
        <span class="cov8" title="1">if opts.FeatureFlags["buildkit-frontend"] </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("BuildKit frontend not yet implemented")
        }</span>
        
        // Create layer from context directory
        <span class="cov8" title="1">layer, err := b.layerFactory.CreateLayer(contextDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create layer from context: %w", err)
        }</span>
        
        // Start with empty base image or use specified base
        <span class="cov8" title="1">var baseImage v1.Image = empty.Image
        if opts.BaseImage != "" </span><span class="cov0" title="0">{
                // TODO: Load base image from reference in future implementation
                // For now, we only support empty base images
                if opts.FeatureFlags["base-image-support"] </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("base image support not yet implemented")
                }</span>
        }
        
        // Add our layer to the base image
        <span class="cov8" title="1">image, err := mutate.AppendLayers(baseImage, layer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to add layer to image: %w", err)
        }</span>
        
        // Generate and apply OCI configuration
        <span class="cov8" title="1">config, err := b.configFactory.GenerateConfig(opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate image config: %w", err)
        }</span>
        
        <span class="cov8" title="1">image, err = b.configFactory.ApplyConfig(image, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply config to image: %w", err)
        }</span>
        
        // Set platform information
        <span class="cov8" title="1">image = mutate.MediaType(image, "application/vnd.oci.image.manifest.v1+json")
        
        return image, nil</span>
}

// BuildTarball creates an OCI image from the context directory and exports it as a tarball.
// This provides offline distribution capabilities for environments without registry access.
func (b *SimpleBuilder) BuildTarball(ctx context.Context, contextDir string, output string, opts BuildOptions) error <span class="cov8" title="1">{
        // Build the image first
        image, err := b.Build(ctx, contextDir, opts)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to build image: %w", err)
        }</span>
        
        // Ensure output directory exists
        <span class="cov8" title="1">outputDir := filepath.Dir(output)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>
        
        // Generate a reference name for the image
        <span class="cov8" title="1">ref := "localhost/built-image:latest"
        if opts.Labels["org.opencontainers.image.ref.name"] != "" </span><span class="cov0" title="0">{
                ref = opts.Labels["org.opencontainers.image.ref.name"]
        }</span>
        
        // Export to tarball
        <span class="cov8" title="1">if err := b.tarballWriter.Write(image, output, ref); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write tarball: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package builder

import (
        "fmt"
        "strconv"
        "strings"
        "time"

        "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/mutate"
)

// ConfigFactory generates OCI image configurations.
// It handles platform settings, environment variables, labels, and container runtime configuration.
type ConfigFactory struct {
        platform v1.Platform
}

// NewConfigFactory creates a new configuration factory for the specified platform.
func NewConfigFactory(platform v1.Platform) *ConfigFactory <span class="cov8" title="1">{
        return &amp;ConfigFactory{
                platform: platform,
        }
}</span>

// GenerateConfig creates an OCI configuration for the image based on build options.
// It sets up the container environment, command, working directory, and metadata.
func (f *ConfigFactory) GenerateConfig(opts BuildOptions) (*v1.ConfigFile, error) <span class="cov8" title="1">{
        // Start with basic configuration
        config := &amp;v1.ConfigFile{
                Architecture: opts.Platform.Architecture,
                OS:          opts.Platform.OS,
                Created:     v1.Time{Time: time.Now()},
                Config: v1.Config{
                        Env:         opts.Env,
                        Cmd:         opts.Cmd,
                        WorkingDir:  opts.WorkingDir,
                        Entrypoint:  opts.Entrypoint,
                        User:        opts.User,
                },
                RootFS: v1.RootFS{
                        Type: "layers",
                },
        }
        
        // Set platform variant if specified
        if opts.Platform.Variant != "" </span><span class="cov0" title="0">{
                config.Variant = opts.Platform.Variant
        }</span>
        
        // Configure exposed ports if specified
        <span class="cov8" title="1">if len(opts.ExposedPorts) &gt; 0 </span><span class="cov0" title="0">{
                config.Config.ExposedPorts = make(map[string]struct{})
                for port := range opts.ExposedPorts </span><span class="cov0" title="0">{
                        config.Config.ExposedPorts[port] = struct{}{}
                }</span>
        }
        
        // Configure volumes if specified
        <span class="cov8" title="1">if len(opts.Volumes) &gt; 0 </span><span class="cov0" title="0">{
                config.Config.Volumes = make(map[string]struct{})
                for volume := range opts.Volumes </span><span class="cov0" title="0">{
                        config.Config.Volumes[volume] = struct{}{}
                }</span>
        }
        
        // Set labels
        <span class="cov8" title="1">if len(opts.Labels) &gt; 0 </span><span class="cov8" title="1">{
                config.Config.Labels = make(map[string]string)
                for k, v := range opts.Labels </span><span class="cov8" title="1">{
                        // Handle special label that should be set to build time
                        if k == "org.opencontainers.image.created" &amp;&amp; v == "" </span><span class="cov8" title="1">{
                                config.Config.Labels[k] = time.Now().UTC().Format(time.RFC3339)
                        }</span> else<span class="cov8" title="1"> {
                                config.Config.Labels[k] = v
                        }</span>
                }
        }
        
        // Validate configuration
        <span class="cov8" title="1">if err := f.validateConfig(config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>
        
        <span class="cov8" title="1">return config, nil</span>
}

// ApplyConfig applies the configuration to an existing image.
// This updates the image's configuration while preserving layers.
func (f *ConfigFactory) ApplyConfig(img v1.Image, config *v1.ConfigFile) (v1.Image, error) <span class="cov8" title="1">{
        // Apply the configuration using mutate
        newImage, err := mutate.ConfigFile(img, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to apply configuration: %w", err)
        }</span>
        
        <span class="cov8" title="1">return newImage, nil</span>
}

// validateConfig validates the OCI configuration for compliance and best practices.
func (f *ConfigFactory) validateConfig(config *v1.ConfigFile) error <span class="cov8" title="1">{
        // Validate architecture
        if config.Architecture == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("architecture cannot be empty")
        }</span>
        
        // Validate OS
        <span class="cov8" title="1">if config.OS == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("operating system cannot be empty")
        }</span>
        
        // Validate working directory format (must be absolute if specified)
        <span class="cov8" title="1">if config.Config.WorkingDir != "" &amp;&amp; !strings.HasPrefix(config.Config.WorkingDir, "/") </span><span class="cov8" title="1">{
                return fmt.Errorf("working directory must be an absolute path: %s", config.Config.WorkingDir)
        }</span>
        
        // Validate exposed ports format
        <span class="cov8" title="1">for port := range config.Config.ExposedPorts </span><span class="cov0" title="0">{
                if err := validatePortFormat(port); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid exposed port format %s: %w", port, err)
                }</span>
        }
        
        // Validate environment variables format
        <span class="cov8" title="1">for _, env := range config.Config.Env </span><span class="cov8" title="1">{
                if !strings.Contains(env, "=") </span><span class="cov0" title="0">{
                        return fmt.Errorf("environment variable must be in KEY=value format: %s", env)
                }</span>
        }
        
        // Validate user format (can be numeric UID or username)
        <span class="cov8" title="1">if config.Config.User != "" </span><span class="cov0" title="0">{
                if err := validateUserFormat(config.Config.User); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid user format %s: %w", config.Config.User, err)
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// validatePortFormat validates that a port specification follows the correct format.
// Valid formats: "port/protocol" (e.g., "80/tcp", "443/tcp", "53/udp")
func validatePortFormat(port string) error <span class="cov0" title="0">{
        parts := strings.Split(port, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("port must be in format 'port/protocol'")
        }</span>
        
        // Validate port number
        <span class="cov0" title="0">portNum, err := strconv.Atoi(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid port number: %s", parts[0])
        }</span>
        
        <span class="cov0" title="0">if portNum &lt; 1 || portNum &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("port number must be between 1 and 65535: %d", portNum)
        }</span>
        
        // Validate protocol
        <span class="cov0" title="0">protocol := strings.ToLower(parts[1])
        if protocol != "tcp" &amp;&amp; protocol != "udp" </span><span class="cov0" title="0">{
                return fmt.Errorf("protocol must be 'tcp' or 'udp': %s", protocol)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// validateUserFormat validates the user specification format.
// Valid formats: numeric UID, username, UID:GID, username:group
func validateUserFormat(user string) error <span class="cov0" title="0">{
        if user == "" </span><span class="cov0" title="0">{
                return nil // Empty is valid (defaults to root)
        }</span>
        
        // Handle user:group format
        <span class="cov0" title="0">parts := strings.Split(user, ":")
        if len(parts) &gt; 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("user specification can have at most one colon")
        }</span>
        
        // Validate user part
        <span class="cov0" title="0">userPart := parts[0]
        if userPart == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user part cannot be empty")
        }</span>
        
        // Check if it's a numeric UID
        <span class="cov0" title="0">if _, err := strconv.Atoi(userPart); err != nil </span><span class="cov0" title="0">{
                // Not numeric, validate as username
                if !isValidUsername(userPart) </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid username format")
                }</span>
        }
        
        // Validate group part if present
        <span class="cov0" title="0">if len(parts) == 2 </span><span class="cov0" title="0">{
                groupPart := parts[1]
                if groupPart == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("group part cannot be empty")
                }</span>
                
                // Check if it's a numeric GID
                <span class="cov0" title="0">if _, err := strconv.Atoi(groupPart); err != nil </span><span class="cov0" title="0">{
                        // Not numeric, validate as group name
                        if !isValidUsername(groupPart) </span><span class="cov0" title="0">{ // Same rules as username
                                return fmt.Errorf("invalid group name format")
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// isValidUsername validates that a string is a valid Unix username.
// This is a basic validation - actual validation depends on the target system.
func isValidUsername(name string) bool <span class="cov0" title="0">{
        if len(name) == 0 || len(name) &gt; 32 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Must start with letter or underscore
        <span class="cov0" title="0">if !(name[0] &gt;= 'a' &amp;&amp; name[0] &lt;= 'z') &amp;&amp; !(name[0] &gt;= 'A' &amp;&amp; name[0] &lt;= 'Z') &amp;&amp; name[0] != '_' </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Can contain letters, numbers, underscores, hyphens
        <span class="cov0" title="0">for _, char := range name[1:] </span><span class="cov0" title="0">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') || 
                         (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '_' || char == '-') </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        <span class="cov0" title="0">return true</span>
}

// DefaultLabels returns a set of recommended OCI labels.
// These provide useful metadata for image management.
func DefaultLabels(source string) map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "org.opencontainers.image.created":     "", // Will be set to build time
                "org.opencontainers.image.source":      source,
                "org.opencontainers.image.title":       "Built with idpbuilder",
                "org.opencontainers.image.description": "OCI image built using go-containerregistry",
                "org.opencontainers.image.vendor":      "CNOE",
                "org.opencontainers.image.version":     "latest",
        }
}</span>

// MergeConfigs merges multiple configuration options.
// Later configs override earlier ones for conflicting settings.
func MergeConfigs(configs ...*v1.ConfigFile) *v1.ConfigFile <span class="cov0" title="0">{
        if len(configs) == 0 </span><span class="cov0" title="0">{
                return &amp;v1.ConfigFile{}
        }</span>
        
        <span class="cov0" title="0">result := &amp;v1.ConfigFile{}
        *result = *configs[0] // Start with first config
        
        for i := 1; i &lt; len(configs); i++ </span><span class="cov0" title="0">{
                cfg := configs[i]
                
                // Override basic fields
                if cfg.Architecture != "" </span><span class="cov0" title="0">{
                        result.Architecture = cfg.Architecture
                }</span>
                <span class="cov0" title="0">if cfg.OS != "" </span><span class="cov0" title="0">{
                        result.OS = cfg.OS
                }</span>
                <span class="cov0" title="0">if cfg.Variant != "" </span><span class="cov0" title="0">{
                        result.Variant = cfg.Variant
                }</span>
                
                // Merge environment variables (later ones override)
                <span class="cov0" title="0">if len(cfg.Config.Env) &gt; 0 </span><span class="cov0" title="0">{
                        result.Config.Env = append(result.Config.Env, cfg.Config.Env...)
                }</span>
                
                // Override command settings
                <span class="cov0" title="0">if len(cfg.Config.Cmd) &gt; 0 </span><span class="cov0" title="0">{
                        result.Config.Cmd = cfg.Config.Cmd
                }</span>
                <span class="cov0" title="0">if len(cfg.Config.Entrypoint) &gt; 0 </span><span class="cov0" title="0">{
                        result.Config.Entrypoint = cfg.Config.Entrypoint
                }</span>
                <span class="cov0" title="0">if cfg.Config.WorkingDir != "" </span><span class="cov0" title="0">{
                        result.Config.WorkingDir = cfg.Config.WorkingDir
                }</span>
                <span class="cov0" title="0">if cfg.Config.User != "" </span><span class="cov0" title="0">{
                        result.Config.User = cfg.Config.User
                }</span>
                
                // Merge labels
                <span class="cov0" title="0">if result.Config.Labels == nil </span><span class="cov0" title="0">{
                        result.Config.Labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for k, v := range cfg.Config.Labels </span><span class="cov0" title="0">{
                        result.Config.Labels[k] = v
                }</span>
                
                // Merge exposed ports
                <span class="cov0" title="0">if result.Config.ExposedPorts == nil </span><span class="cov0" title="0">{
                        result.Config.ExposedPorts = make(map[string]struct{})
                }</span>
                <span class="cov0" title="0">for port := range cfg.Config.ExposedPorts </span><span class="cov0" title="0">{
                        result.Config.ExposedPorts[port] = struct{}{}
                }</span>
                
                // Merge volumes
                <span class="cov0" title="0">if result.Config.Volumes == nil </span><span class="cov0" title="0">{
                        result.Config.Volumes = make(map[string]struct{})
                }</span>
                <span class="cov0" title="0">for volume := range cfg.Config.Volumes </span><span class="cov0" title="0">{
                        result.Config.Volumes[volume] = struct{}{}
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package builder

import (
        "archive/tar"
        "bytes"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
        "syscall"
        "time"

        "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/tarball"
)

// LayerFactory creates OCI layers from directory contents.
// It handles file walking, tar archive creation, and metadata preservation.
type LayerFactory struct {
        preservePermissions bool
        preserveTimestamps  bool
}

// NewLayerFactory creates a new layer factory with default settings.
// It preserves permissions but normalizes timestamps for reproducible builds.
func NewLayerFactory() *LayerFactory <span class="cov8" title="1">{
        return &amp;LayerFactory{
                preservePermissions: true,
                preserveTimestamps:  false, // Normalize for reproducible builds
        }
}</span>

// CreateLayer builds an OCI layer from directory contents.
// It walks the directory tree, creates a tar archive, and returns it as a v1.Layer.
func (f *LayerFactory) CreateLayer(contextDir string) (v1.Layer, error) <span class="cov8" title="1">{
        // Validate context directory
        if contextDir == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("context directory cannot be empty")
        }</span>
        
        // Clean the path to ensure consistent handling
        <span class="cov8" title="1">contextDir = filepath.Clean(contextDir)
        
        // Create tar archive in memory
        var buf bytes.Buffer
        tw := tar.NewWriter(&amp;buf)
        defer tw.Close()
        
        // Walk the directory tree and add files to tar
        err := filepath.WalkDir(contextDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to access path %s: %w", path, err)
                }</span>
                
                // Skip the root directory itself
                <span class="cov8" title="1">if path == contextDir </span><span class="cov8" title="1">{
                        return nil
                }</span>
                
                // Get file info for metadata
                <span class="cov8" title="1">info, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get info for %s: %w", path, err)
                }</span>
                
                // Calculate relative path within the context
                <span class="cov8" title="1">relPath, err := filepath.Rel(contextDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to calculate relative path for %s: %w", path, err)
                }</span>
                
                // Convert Windows paths to Unix paths for OCI compliance
                <span class="cov8" title="1">tarPath := filepath.ToSlash(relPath)
                
                // Add file to tar archive
                if err := f.addFileToTar(tw, path, tarPath, info); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add file %s to tar: %w", path, err)
                }</span>
                
                <span class="cov8" title="1">return nil</span>
        })
        
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to walk context directory: %w", err)
        }</span>
        
        // Close tar writer to finalize archive
        <span class="cov8" title="1">if err := tw.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to close tar writer: %w", err)
        }</span>
        
        // Create layer from tar archive
        <span class="cov8" title="1">reader := bytes.NewReader(buf.Bytes())
        layer, err := tarball.LayerFromReader(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create layer from tar: %w", err)
        }</span>
        
        <span class="cov8" title="1">return layer, nil</span>
}

// addFileToTar adds a single file to the tar archive with appropriate metadata.
// It handles regular files, directories, and symlinks according to OCI specifications.
func (f *LayerFactory) addFileToTar(tw *tar.Writer, srcPath, tarPath string, info os.FileInfo) error <span class="cov8" title="1">{
        // Create tar header from file info
        header, err := tar.FileInfoHeader(info, "")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create tar header: %w", err)
        }</span>
        
        // Set the name in the tar archive
        <span class="cov8" title="1">header.Name = tarPath
        
        // Handle timestamps for reproducible builds
        if !f.preserveTimestamps </span><span class="cov8" title="1">{
                // Use a fixed timestamp for reproducible builds
                fixedTime := time.Unix(0, 0)
                header.ModTime = fixedTime
                header.AccessTime = fixedTime
                header.ChangeTime = fixedTime
        }</span>
        
        // Handle permissions
        <span class="cov8" title="1">if f.preservePermissions </span><span class="cov8" title="1">{
                // Keep original permissions
                header.Mode = int64(info.Mode())
        }</span> else<span class="cov0" title="0"> {
                // Normalize permissions
                if info.IsDir() </span><span class="cov0" title="0">{
                        header.Mode = 0755
                }</span> else<span class="cov0" title="0"> {
                        header.Mode = 0644
                }</span>
        }
        
        // Handle different file types
        <span class="cov8" title="1">switch info.Mode() &amp; os.ModeType </span>{
        case 0:<span class="cov8" title="1"> // Regular file
                // Write header
                if err := tw.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write header for regular file: %w", err)
                }</span>
                
                // Open and copy file content
                <span class="cov8" title="1">file, err := os.Open(srcPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to open file for reading: %w", err)
                }</span>
                <span class="cov8" title="1">defer file.Close()
                
                _, err = io.Copy(tw, file)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to copy file content: %w", err)
                }</span>
                
        case os.ModeDir:<span class="cov8" title="1"> // Directory
                // Ensure directory path ends with slash for tar compliance
                if !strings.HasSuffix(header.Name, "/") </span><span class="cov8" title="1">{
                        header.Name += "/"
                }</span>
                <span class="cov8" title="1">header.Size = 0
                
                if err := tw.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write header for directory: %w", err)
                }</span>
                
        case os.ModeSymlink:<span class="cov0" title="0"> // Symbolic link
                // Read link target
                linkTarget, err := os.Readlink(srcPath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to read symlink target: %w", err)
                }</span>
                
                <span class="cov0" title="0">header.Linkname = linkTarget
                header.Size = 0
                
                if err := tw.WriteHeader(header); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write header for symlink: %w", err)
                }</span>
                
        default:<span class="cov0" title="0">
                // Skip special files (devices, named pipes, etc.)
                // These are not commonly needed in container images
                return nil</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// WithPermissionPreservation configures whether to preserve original file permissions.
func (f *LayerFactory) WithPermissionPreservation(preserve bool) *LayerFactory <span class="cov0" title="0">{
        f.preservePermissions = preserve
        return f
}</span>

// WithTimestampPreservation configures whether to preserve original file timestamps.
func (f *LayerFactory) WithTimestampPreservation(preserve bool) *LayerFactory <span class="cov0" title="0">{
        f.preserveTimestamps = preserve
        return f
}</span>

// GetLayerInfo returns information about a layer.
// This is useful for debugging and validation.
func GetLayerInfo(layer v1.Layer) (LayerInfo, error) <span class="cov8" title="1">{
        digest, err := layer.Digest()
        if err != nil </span><span class="cov0" title="0">{
                return LayerInfo{}, fmt.Errorf("failed to get layer digest: %w", err)
        }</span>
        
        <span class="cov8" title="1">size, err := layer.Size()
        if err != nil </span><span class="cov0" title="0">{
                return LayerInfo{}, fmt.Errorf("failed to get layer size: %w", err)
        }</span>
        
        <span class="cov8" title="1">diffID, err := layer.DiffID()
        if err != nil </span><span class="cov0" title="0">{
                return LayerInfo{}, fmt.Errorf("failed to get layer diff ID: %w", err)
        }</span>
        
        <span class="cov8" title="1">mediaType, err := layer.MediaType()
        if err != nil </span><span class="cov0" title="0">{
                return LayerInfo{}, fmt.Errorf("failed to get layer media type: %w", err)
        }</span>
        
        <span class="cov8" title="1">return LayerInfo{
                Digest:    digest,
                Size:      size,
                DiffID:    diffID,
                MediaType: string(mediaType),
        }, nil</span>
}

// LayerInfo contains metadata about an OCI layer.
type LayerInfo struct {
        Digest    v1.Hash             `json:"digest"`
        Size      int64               `json:"size"`
        DiffID    v1.Hash             `json:"diffId"`
        MediaType string              `json:"mediaType"`
}

// isExecutable checks if a file has execute permissions.
// This is used to preserve executable bits in the tar archive.
func isExecutable(info os.FileInfo) bool <span class="cov0" title="0">{
        if info.Mode()&amp;0111 != 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// getFileOwnership returns the UID and GID of a file.
// This works on Unix-like systems but gracefully handles other platforms.
func getFileOwnership(info os.FileInfo) (int, int) <span class="cov0" title="0">{
        if stat, ok := info.Sys().(*syscall.Stat_t); ok </span><span class="cov0" title="0">{
                return int(stat.Uid), int(stat.Gid)
        }</span>
        // Default to root if we can't determine ownership
        <span class="cov0" title="0">return 0, 0</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package builder

import "github.com/google/go-containerregistry/pkg/v1"

// BuildOptions configures the image build process.
// It provides platform specification, base image settings, and container configuration.
type BuildOptions struct {
        // Platform specifies the target platform (OS/architecture) for the image.
        // Defaults to linux/amd64 if not specified.
        Platform v1.Platform `json:"platform,omitempty"`
        
        // BaseImage specifies an optional base image reference.
        // If empty, builds from scratch (empty base image).
        BaseImage string `json:"baseImage,omitempty"`
        
        // Labels contains OCI labels to apply to the image.
        // Common labels include org.opencontainers.image.* metadata.
        Labels map[string]string `json:"labels,omitempty"`
        
        // Env contains environment variables to set in the container.
        // Format: ["KEY=value", "ANOTHER_KEY=another_value"]
        Env []string `json:"env,omitempty"`
        
        // WorkingDir sets the working directory inside the container.
        // Must be an absolute path if specified.
        WorkingDir string `json:"workingDir,omitempty"`
        
        // Entrypoint defines the container entrypoint.
        // When specified, overrides any base image entrypoint.
        Entrypoint []string `json:"entrypoint,omitempty"`
        
        // Cmd defines the default command and arguments.
        // Used when container is run without explicit command.
        Cmd []string `json:"cmd,omitempty"`
        
        // FeatureFlags enables/disables incomplete functionality per R307.
        // This ensures features under development don't break builds.
        FeatureFlags map[string]bool `json:"featureFlags,omitempty"`
        
        // User sets the user ID or name for container execution.
        // Can be numeric UID or username that exists in the image.
        User string `json:"user,omitempty"`
        
        // ExposedPorts declares ports that the container will listen on.
        // Format: map of "port/protocol" -&gt; struct{} (e.g., "80/tcp")
        ExposedPorts map[string]struct{} `json:"exposedPorts,omitempty"`
        
        // Volumes declares mount points for the container.
        // Format: map of path -&gt; struct{} (e.g., "/data")
        Volumes map[string]struct{} `json:"volumes,omitempty"`
}

// DefaultBuildOptions returns a BuildOptions struct with sensible defaults.
// This provides a starting point for common build scenarios.
func DefaultBuildOptions() BuildOptions <span class="cov8" title="1">{
        return BuildOptions{
                Platform: v1.Platform{
                        OS:           "linux",
                        Architecture: "amd64",
                },
                Labels: map[string]string{
                        "org.opencontainers.image.created": "",  // Will be set to build time
                        "org.opencontainers.image.source":  "idpbuilder",
                },
                FeatureFlags: make(map[string]bool),
        }
}</span>

// WithPlatform sets the target platform for the build.
// Common platforms: linux/amd64, linux/arm64, darwin/amd64, darwin/arm64
func (opts BuildOptions) WithPlatform(os, arch string) BuildOptions <span class="cov8" title="1">{
        opts.Platform = v1.Platform{
                OS:           os,
                Architecture: arch,
        }
        return opts
}</span>

// WithBaseImage sets the base image for the build.
// The base image will be pulled and used as the foundation.
func (opts BuildOptions) WithBaseImage(ref string) BuildOptions <span class="cov8" title="1">{
        opts.BaseImage = ref
        return opts
}</span>

// WithLabels merges the provided labels with existing ones.
// Existing labels with the same key will be overwritten.
func (opts BuildOptions) WithLabels(labels map[string]string) BuildOptions <span class="cov8" title="1">{
        if opts.Labels == nil </span><span class="cov0" title="0">{
                opts.Labels = make(map[string]string)
        }</span>
        <span class="cov8" title="1">for k, v := range labels </span><span class="cov8" title="1">{
                opts.Labels[k] = v
        }</span>
        <span class="cov8" title="1">return opts</span>
}

// WithWorkingDir sets the working directory for the container.
func (opts BuildOptions) WithWorkingDir(dir string) BuildOptions <span class="cov8" title="1">{
        opts.WorkingDir = dir
        return opts
}</span>

// WithEntrypoint sets the container entrypoint command.
func (opts BuildOptions) WithEntrypoint(entrypoint ...string) BuildOptions <span class="cov8" title="1">{
        opts.Entrypoint = entrypoint
        return opts
}</span>

// WithCmd sets the default container command.
func (opts BuildOptions) WithCmd(cmd ...string) BuildOptions <span class="cov8" title="1">{
        opts.Cmd = cmd
        return opts
}</span>

// WithEnv adds environment variables to the container.
// Variables should be in "KEY=value" format.
func (opts BuildOptions) WithEnv(env ...string) BuildOptions <span class="cov8" title="1">{
        opts.Env = append(opts.Env, env...)
        return opts
}</span>

// WithFeatureFlags enables specific feature flags.
// Used for R307 compliance to gate incomplete functionality.
func (opts BuildOptions) WithFeatureFlags(flags map[string]bool) BuildOptions <span class="cov8" title="1">{
        if opts.FeatureFlags == nil </span><span class="cov0" title="0">{
                opts.FeatureFlags = make(map[string]bool)
        }</span>
        <span class="cov8" title="1">for k, v := range flags </span><span class="cov8" title="1">{
                opts.FeatureFlags[k] = v
        }</span>
        <span class="cov8" title="1">return opts</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package builder

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/google/go-containerregistry/pkg/name"
        "github.com/google/go-containerregistry/pkg/v1"
        "github.com/google/go-containerregistry/pkg/v1/tarball"
)

// TarballWriter exports OCI images as tarball files.
// It supports standard tarball format for maximum compatibility.
type TarballWriter struct {
        options TarballOptions
}

// TarballOptions configures tarball export behavior.
type TarballOptions struct {
        // Compress enables gzip compression of the tarball
        Compress bool
        
        // Platform specifies platform selection for multi-arch images
        Platform *v1.Platform
        
        // IncludeManifest includes the image manifest in the tarball
        IncludeManifest bool
}

// NewTarballWriter creates a new tarball writer.
func NewTarballWriter() *TarballWriter <span class="cov8" title="1">{
        return &amp;TarballWriter{
                options: TarballOptions{
                        Compress:        false, // Default to uncompressed for speed
                        IncludeManifest: true,
                },
        }
}</span>

// NewTarballWriterWithOptions creates a tarball writer with custom options.
func NewTarballWriterWithOptions(opts TarballOptions) *TarballWriter <span class="cov0" title="0">{
        return &amp;TarballWriter{
                options: opts,
        }
}</span>

// Write exports an OCI image to a tarball file.
// The tarball can be imported into Docker, Podman, or other container runtimes.
func (w *TarballWriter) Write(img v1.Image, outputPath string, ref string) error <span class="cov8" title="1">{
        // Validate input parameters
        if img == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("image cannot be nil")
        }</span>
        <span class="cov8" title="1">if outputPath == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("output path cannot be empty")
        }</span>
        <span class="cov8" title="1">if ref == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("image reference cannot be empty")
        }</span>
        
        // Parse and validate the reference
        <span class="cov8" title="1">imageRef, err := name.ParseReference(ref, name.WeakValidation)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid image reference %s: %w", ref, err)
        }</span>
        
        // Ensure output directory exists
        <span class="cov8" title="1">outputDir := filepath.Dir(outputPath)
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory %s: %w", outputDir, err)
        }</span>
        
        // Create the output file
        <span class="cov8" title="1">outputFile, err := os.Create(outputPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output file %s: %w", outputPath, err)
        }</span>
        <span class="cov8" title="1">defer outputFile.Close()
        
        // Create tag-to-image map for the tarball
        tagToImage := map[name.Tag]v1.Image{}
        
        // Handle reference type
        switch typedRef := imageRef.(type) </span>{
        case name.Tag:<span class="cov8" title="1">
                tagToImage[typedRef] = img</span>
        case name.Digest:<span class="cov0" title="0">
                // For digest references, create a tag with the digest
                tag, err := name.NewTag(fmt.Sprintf("%s:%s", typedRef.Repository.Name(), "latest"))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create tag from digest: %w", err)
                }</span>
                <span class="cov0" title="0">tagToImage[tag] = img</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported reference type: %T", imageRef)</span>
        }
        
        // Write the tarball using the modern API
        <span class="cov8" title="1">err = tarball.MultiWriteToFile(outputPath, tagToImage)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write tarball: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// WriteMultiple exports multiple images to a single tarball.
// This is useful for batch export of related images.
func (w *TarballWriter) WriteMultiple(images map[string]v1.Image, outputPath string) error <span class="cov0" title="0">{
        if len(images) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no images provided for export")
        }</span>
        
        // Convert string references to proper tags
        <span class="cov0" title="0">tagToImage := make(map[name.Tag]v1.Image)
        for refStr, img := range images </span><span class="cov0" title="0">{
                tag, err := name.NewTag(refStr, name.WeakValidation)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid reference %s: %w", refStr, err)
                }</span>
                <span class="cov0" title="0">tagToImage[tag] = img</span>
        }
        
        // Write multi-image tarball
        <span class="cov0" title="0">err := tarball.MultiWriteToFile(outputPath, tagToImage)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write multi-image tarball: %w", err)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// GetTarballInfo returns information about an existing tarball file.
// This is useful for validation and inspection.
func GetTarballInfo(tarballPath string) (*TarballInfo, error) <span class="cov0" title="0">{
        // Check if file exists
        info, err := os.Stat(tarballPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tarball file not found: %w", err)
        }</span>
        
        <span class="cov0" title="0">return &amp;TarballInfo{
                Path: tarballPath,
                Size: info.Size(),
        }, nil</span>
}

// TarballInfo contains metadata about a tarball file.
type TarballInfo struct {
        Path string `json:"path"`
        Size int64  `json:"size"`
}

// LoadFromTarball loads an image from a tarball file.
// This is the reverse operation of Write().
func LoadFromTarball(tarballPath string, ref string) (v1.Image, error) <span class="cov0" title="0">{
        // Parse reference
        tag, err := name.NewTag(ref, name.WeakValidation)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid reference %s: %w", ref, err)
        }</span>
        
        // Load image from tarball
        <span class="cov0" title="0">img, err := tarball.ImageFromPath(tarballPath, &amp;tag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load image from tarball: %w", err)
        }</span>
        
        <span class="cov0" title="0">return img, nil</span>
}

// ValidateTarball checks if a tarball file is valid and contains expected content.
func ValidateTarball(tarballPath string) error <span class="cov0" title="0">{
        // Check file existence and readability
        file, err := os.Open(tarballPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot open tarball file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()
        
        // Basic file size check (should not be empty)
        info, err := file.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot stat tarball file: %w", err)
        }</span>
        
        <span class="cov0" title="0">if info.Size() == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("tarball file is empty")
        }</span>
        
        // TODO: Add more sophisticated validation like:
        // - Check tar archive structure
        // - Validate OCI/Docker format compliance
        // - Check for required files (manifest, config, layers)
        
        <span class="cov0" title="0">return nil</span>
}

// CompressTarball compresses an existing tarball using gzip.
// This reduces file size but increases CPU usage.
func CompressTarball(inputPath, outputPath string) error <span class="cov0" title="0">{
        // This would implement gzip compression
        // For now, return an error indicating it's not implemented
        return fmt.Errorf("tarball compression not yet implemented")
}</span>

// WithCompression enables gzip compression of the output tarball.
func (w *TarballWriter) WithCompression(compress bool) *TarballWriter <span class="cov0" title="0">{
        w.options.Compress = compress
        return w
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
