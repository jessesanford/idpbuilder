# Orchestrator - WAVE_COMPLETE State Rules

## State Context
You have completed all efforts in a wave and need to integrate, validate, and prepare for next steps.

┌─────────────────────────────────────────────────────────────────┐
│ RULE R105.0.0 - WAVE_COMPLETE Rules                            │
│ Source: rule-library/RULE-REGISTRY.md#R105                     │
├─────────────────────────────────────────────────────────────────┤
│ WAVE COMPLETION PROTOCOL:                                      │
│ 1. Validate all efforts are genuinely complete                │
│ 2. Verify size compliance for every effort                    │
│ 3. Run comprehensive wave-level validation                    │
│ 4. Create wave integration branch                             │
│ 5. Request architect review if needed                         │
│ 6. Plan next wave or phase transition                         │
└─────────────────────────────────────────────────────────────────┘

## Wave Completion Validation

┌─────────────────────────────────────────────────────────────────┐
│ RULE R035.0.0 - Phase Completion Testing                       │
│ Source: rule-library/RULE-REGISTRY.md#R035                     │
├─────────────────────────────────────────────────────────────────┤
│ MANDATORY VALIDATION CHECKLIST:                               │
│                                                                 │
│ For EACH effort in the wave:                                  │
│ ✅ Implementation complete per plan                           │
│ ✅ All tests passing at required coverage                    │
│ ✅ Size under 800 lines (verified with tmc-pr-line-counter)  │
│ ✅ Code committed and pushed                                 │
│ ✅ Work log updated and complete                             │
│ ✅ Code review passed                                        │
│                                                                 │
│ For the WAVE overall:                                         │
│ ✅ All dependencies satisfied                                │
│ ✅ Integration tests passing                                 │
│ ✅ No architecture violations                                │
│ ✅ Performance within acceptable ranges                       │
└─────────────────────────────────────────────────────────────────┘

## Effort Completion Verification

```python
def verify_effort_completion(effort_id, effort_data):
    """Verify an individual effort is truly complete"""
    
    working_dir = effort_data['working_dir']
    branch = effort_data['branch']
    
    verification_results = {
        'effort_id': effort_id,
        'checks': {},
        'overall_complete': True,
        'issues': []
    }
    
    # 1. Implementation plan completion check
    plan_check = verify_implementation_plan_complete(working_dir)
    verification_results['checks']['plan_complete'] = plan_check
    if not plan_check['complete']:
        verification_results['overall_complete'] = False
        verification_results['issues'].extend(plan_check['missing_items'])
    
    # 2. Test coverage verification
    test_check = verify_test_coverage(working_dir)
    verification_results['checks']['test_coverage'] = test_check
    if not test_check['meets_requirements']:
        verification_results['overall_complete'] = False
        verification_results['issues'].append(f"Test coverage {test_check['coverage']}% < required {test_check['required']}%")
    
    # 3. Size compliance check (CRITICAL)
    size_check = verify_size_compliance(branch)
    verification_results['checks']['size_compliance'] = size_check
    if not size_check['compliant']:
        verification_results['overall_complete'] = False
        verification_results['issues'].append(f"Size {size_check['lines']} > limit {size_check['limit']}")
    
    # 4. Git status verification
    git_check = verify_git_status(working_dir, branch)
    verification_results['checks']['git_status'] = git_check
    if not git_check['clean']:
        verification_results['overall_complete'] = False
        verification_results['issues'].extend(git_check['issues'])
    
    # 5. Work log completeness
    worklog_check = verify_work_log_complete(working_dir)
    verification_results['checks']['work_log'] = worklog_check
    if not worklog_check['complete']:
        verification_results['overall_complete'] = False
        verification_results['issues'].append("Work log incomplete or missing final entries")
    
    return verification_results

def verify_size_compliance(branch):
    """Verify effort size using mandatory line counter"""
    
    try:
        result = subprocess.run([
            '/workspaces/kcp-shared-tools/tmc-pr-line-counter.sh',
            '-c', branch
        ], capture_output=True, text=True, check=True)
        
        # Parse the output to get line count
        lines = int(result.stdout.strip().split()[-1])
        
        return {
            'compliant': lines <= 800,
            'lines': lines,
            'limit': 800,
            'command_output': result.stdout.strip()
        }
        
    except subprocess.CalledProcessError as e:
        return {
            'compliant': False,
            'error': f"Line counter failed: {e}",
            'lines': 'unknown',
            'limit': 800
        }
    except Exception as e:
        return {
            'compliant': False,
            'error': f"Size check failed: {e}",
            'lines': 'unknown',
            'limit': 800
        }
```

## Wave-Level Integration Validation

┌─────────────────────────────────────────────────────────────────┐
│ RULE R034.0.0 - Integration Requirements                       │
│ Source: rule-library/RULE-REGISTRY.md#R034                     │
├─────────────────────────────────────────────────────────────────┤
│ WAVE INTEGRATION PROCESS:                                      │
│ 1. Create wave integration branch                             │
│ 2. Merge all effort branches sequentially                     │
│ 3. Resolve any integration conflicts                          │
│ 4. Run full test suite on integrated code                     │
│ 5. Validate combined size still compliant                     │
│ 6. Performance and smoke testing                              │
└─────────────────────────────────────────────────────────────────┘

```bash
#!/bin/bash
# Wave integration script

PHASE=$1
WAVE=$2
INTEGRATION_BRANCH="phase${PHASE}/wave${WAVE}-integration"

echo "🔗 Creating wave integration branch: $INTEGRATION_BRANCH"

# Create integration branch
git checkout -b "$INTEGRATION_BRANCH"

# Get all effort branches for this wave
EFFORT_BRANCHES=$(git branch -r | grep "phase${PHASE}/wave${WAVE}/effort" | sed 's/origin\///')

for EFFORT_BRANCH in $EFFORT_BRANCHES; do
    echo "Merging effort branch: $EFFORT_BRANCH"
    
    # Merge with no-fast-forward to maintain history
    git merge "origin/$EFFORT_BRANCH" --no-ff -m "integrate: $EFFORT_BRANCH into wave"
    
    if [ $? -ne 0 ]; then
        echo "❌ Conflict detected merging $EFFORT_BRANCH"
        echo "Manual resolution required before continuing"
        exit 1
    fi
    
    echo "✅ Successfully merged $EFFORT_BRANCH"
done

# Validate integrated size
echo "📏 Checking integrated wave size..."
TOTAL_LINES=$(/workspaces/kcp-shared-tools/tmc-pr-line-counter.sh -c "$INTEGRATION_BRANCH" | tail -1)
echo "Total lines in wave: $TOTAL_LINES"

# Run tests on integration
echo "🧪 Running tests on integrated wave..."
make test
if [ $? -ne 0 ]; then
    echo "❌ Tests failed on wave integration"
    exit 1
fi

echo "✅ Wave integration complete and validated"
```

## Architect Review Decision

┌─────────────────────────────────────────────────────────────────┐
│ RULE R033.0.0 - Architect Review Gates                         │
│ Source: rule-library/RULE-REGISTRY.md#R033                     │
├─────────────────────────────────────────────────────────────────┤
│ ARCHITECT REVIEW TRIGGERS:                                     │
│                                                                 │
│ MANDATORY REVIEW:                                              │
│ - End of each phase                                           │
│ - Any effort exceeded size limits (split required)            │
│ - Architecture patterns violated                              │
│ - Performance regressions detected                            │
│                                                                 │
│ OPTIONAL REVIEW (Recommended):                                │
│ - Complex wave with many integrations                         │
│ - New patterns or technologies introduced                     │
│ - Significant API changes                                     │
└─────────────────────────────────────────────────────────────────┘

```python
def should_request_architect_review(wave_data):
    """Determine if architect review is needed for this wave"""
    
    review_decision = {
        'review_required': False,
        'review_type': None,
        'reasons': [],
        'urgency': 'NORMAL'
    }
    
    # Check mandatory review triggers
    if wave_data.get('phase_end', False):
        review_decision['review_required'] = True
        review_decision['review_type'] = 'PHASE_COMPLETION'
        review_decision['reasons'].append('End of phase - mandatory review')
        review_decision['urgency'] = 'HIGH'
    
    # Check for size violations in any effort
    size_violations = []
    for effort in wave_data.get('efforts', []):
        if not effort.get('size_compliant', True):
            size_violations.append(effort['id'])
    
    if size_violations:
        review_decision['review_required'] = True
        review_decision['review_type'] = 'SIZE_VIOLATION_REVIEW'
        review_decision['reasons'].append(f'Size violations in efforts: {size_violations}')
        review_decision['urgency'] = 'CRITICAL'
    
    # Check for architecture violations
    arch_violations = wave_data.get('architecture_violations', [])
    if arch_violations:
        review_decision['review_required'] = True
        review_decision['review_type'] = 'ARCHITECTURE_VIOLATION'
        review_decision['reasons'].extend(arch_violations)
        review_decision['urgency'] = 'HIGH'
    
    # Check optional review triggers
    if not review_decision['review_required']:
        # Complex integration (>4 efforts)
        if len(wave_data.get('efforts', [])) > 4:
            review_decision['review_required'] = True
            review_decision['review_type'] = 'COMPLEXITY_REVIEW'
            review_decision['reasons'].append('Complex wave with many efforts')
            review_decision['urgency'] = 'NORMAL'
        
        # New patterns detected
        if wave_data.get('new_patterns_introduced', False):
            review_decision['review_required'] = True
            review_decision['review_type'] = 'PATTERN_REVIEW'
            review_decision['reasons'].append('New architectural patterns introduced')
            review_decision['urgency'] = 'NORMAL'
    
    return review_decision
```

## Next Wave Planning

```yaml
# Wave completion analysis for planning
wave_completion_analysis:
  completed_wave:
    phase: 1
    wave: 2
    completed_at: "2025-08-23T17:30:00Z"
    efforts_completed: 4
    total_lines_delivered: 2847
    
  performance_metrics:
    wave_duration_hours: 6.5
    average_effort_size: 711
    integration_conflicts: 1
    test_pass_rate: 100
    
  lessons_learned:
    - "API types effort completed ahead of schedule"
    - "Controller effort had minor integration conflict with webhooks"
    - "Size management worked well with 700-line target per effort"
    
  next_wave_recommendations:
    - "Continue with 4 effort pattern"
    - "Monitor controller-webhook dependencies closely"
    - "Consider pre-integration dependency analysis"
    
  readiness_for_next:
    dependencies_resolved: true
    blockers_identified: []
    resource_availability: "FULL"
    estimated_start: "2025-08-23T18:00:00Z"
```

## State Transition Decision Matrix

```python
def determine_next_state(wave_completion_data):
    """Determine next state after wave completion"""
    
    # Check if this completes the current phase
    if wave_completion_data.get('phase_complete', False):
        return {
            'next_state': 'WAVE_REVIEW',
            'reason': 'Phase complete - architect phase review required',
            'data': {
                'review_type': 'PHASE_COMPLETION',
                'phase': wave_completion_data['phase']
            }
        }
    
    # Check if architect review is required for other reasons
    review_decision = should_request_architect_review(wave_completion_data)
    if review_decision['review_required']:
        return {
            'next_state': 'WAVE_REVIEW',
            'reason': f'Architect review required: {review_decision["review_type"]}',
            'data': review_decision
        }
    
    # Check if integration issues need resolution
    if wave_completion_data.get('integration_issues', []):
        return {
            'next_state': 'INTEGRATION',
            'reason': 'Integration issues require resolution',
            'data': {
                'issues': wave_completion_data['integration_issues']
            }
        }
    
    # Check if any efforts need splits due to size
    efforts_needing_splits = [
        effort for effort in wave_completion_data.get('efforts', [])
        if not effort.get('size_compliant', True)
    ]
    
    if efforts_needing_splits:
        return {
            'next_state': 'SPAWN_AGENTS',
            'reason': 'Efforts need splitting due to size violations',
            'data': {
                'spawn_type': 'CODE_REVIEWER_SPLITS',
                'efforts_to_split': efforts_needing_splits
            }
        }
    
    # Check if ready for next wave
    next_wave_ready = wave_completion_data.get('next_wave_ready', True)
    if next_wave_ready:
        return {
            'next_state': 'WAVE_START',
            'reason': 'Ready to start next wave',
            'data': {
                'next_phase': wave_completion_data['phase'],
                'next_wave': wave_completion_data['wave'] + 1
            }
        }
    
    # Need to wait or investigate issues
    return {
        'next_state': 'MONITOR',
        'reason': 'Monitoring remaining completion tasks',
        'data': {
            'pending_tasks': wave_completion_data.get('pending_tasks', [])
        }
    }
```

## Wave Completion Reporting

```python
def generate_wave_completion_report(wave_data):
    """Generate comprehensive wave completion report"""
    
    report = {
        'wave_id': f"phase{wave_data['phase']}_wave{wave_data['wave']}",
        'completion_timestamp': datetime.now().isoformat(),
        'summary': generate_wave_summary(wave_data),
        'effort_details': generate_effort_reports(wave_data['efforts']),
        'integration_results': wave_data.get('integration_results', {}),
        'performance_metrics': calculate_wave_performance_metrics(wave_data),
        'quality_gates': validate_wave_quality_gates(wave_data),
        'recommendations': generate_next_wave_recommendations(wave_data)
    }
    
    print("📋 WAVE COMPLETION REPORT")
    print(f"Wave: {report['wave_id']}")
    print(f"Efforts Completed: {len(report['effort_details'])}")
    print(f"Total Lines Delivered: {report['performance_metrics']['total_lines']}")
    print(f"Quality Gates: {'✅ PASSED' if report['quality_gates']['all_passed'] else '❌ ISSUES'}")
    
    if not report['quality_gates']['all_passed']:
        print("Quality Gate Issues:")
        for issue in report['quality_gates']['failed_gates']:
            print(f"  - {issue}")
    
    return report

def validate_wave_quality_gates(wave_data):
    """Validate all quality gates for wave completion"""
    
    quality_gates = {
        'all_efforts_complete': True,
        'size_compliance': True,
        'test_coverage': True,
        'integration_clean': True,
        'performance_acceptable': True
    }
    
    failed_gates = []
    
    # Check each effort
    for effort in wave_data.get('efforts', []):
        if not effort.get('complete', False):
            quality_gates['all_efforts_complete'] = False
            failed_gates.append(f"Effort {effort['id']} not complete")
        
        if not effort.get('size_compliant', True):
            quality_gates['size_compliance'] = False
            failed_gates.append(f"Effort {effort['id']} exceeds size limits")
        
        if effort.get('test_coverage', 100) < effort.get('required_coverage', 80):
            quality_gates['test_coverage'] = False
            failed_gates.append(f"Effort {effort['id']} below test coverage requirements")
    
    # Check integration results
    integration = wave_data.get('integration_results', {})
    if integration.get('conflicts', 0) > 0:
        quality_gates['integration_clean'] = False
        failed_gates.append(f"Integration conflicts detected: {integration['conflicts']}")
    
    # Check performance metrics
    perf = wave_data.get('performance_metrics', {})
    if perf.get('build_time_minutes', 0) > 10:  # Build should complete in <10 min
        quality_gates['performance_acceptable'] = False
        failed_gates.append(f"Build time too long: {perf['build_time_minutes']} minutes")
    
    return {
        'quality_gates': quality_gates,
        'all_passed': all(quality_gates.values()),
        'failed_gates': failed_gates,
        'pass_count': sum(quality_gates.values()),
        'total_gates': len(quality_gates)
    }
```

## State Transitions

From WAVE_COMPLETE state:
- **ARCHITECT_REVIEW_REQUIRED** → WAVE_REVIEW (Spawn Architect)
- **INTEGRATION_NEEDED** → INTEGRATION (Merge and validate)
- **SPLITS_REQUIRED** → SPAWN_AGENTS (Code Reviewer for splits)
- **NEXT_WAVE_READY** → WAVE_START (Continue with next wave)
- **PHASE_COMPLETE** → WAVE_REVIEW (Phase-level architect review)
- **ISSUES_DETECTED** → ERROR_RECOVERY (Address completion issues)