#!/bin/bash

# 🏭 SOFTWARE FACTORY 2.0 - EFFORT BACKUP UTILITY
# ═══════════════════════════════════════════════════════════════════════════
# Purpose: Backup all effort directories with their current state before
#          major operations or as a safety measure
# Usage: ./backup-all-efforts.sh [backup-name]
# 
# Example: ./backup-all-efforts.sh pre-integration
#
# This script:
# 1. Creates timestamped backup of all efforts
# 2. Preserves git state and uncommitted changes
# 3. Creates restoration manifest
# 4. Optionally compresses backup for storage
# ═══════════════════════════════════════════════════════════════════════════

set -euo pipefail

# ANSI Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Configuration
BACKUP_NAME="${1:-backup}"
TIMESTAMP=$(date '+%Y%m%d-%H%M%S')
BACKUP_DIR="backups/efforts-${BACKUP_NAME}-${TIMESTAMP}"
EFFORTS_ROOT="efforts"
MANIFEST_FILE="${BACKUP_DIR}/backup-manifest.json"
BACKUP_LOG="${BACKUP_DIR}/backup.log"

# Logging function
log() {
    local level="$1"
    shift
    local message="$*"
    echo -e "${level}${message}${NC}" | tee -a "$BACKUP_LOG" 2>/dev/null || echo -e "${level}${message}${NC}"
}

# Print header
print_header() {
    echo "═══════════════════════════════════════════════════════════════════════════"
    echo "🏭 SOFTWARE FACTORY 2.0 - EFFORT BACKUP UTILITY"
    echo "═══════════════════════════════════════════════════════════════════════════"
    echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S %Z')"
    echo "Backup Name: ${BACKUP_NAME}"
    echo "Backup Directory: ${BACKUP_DIR}"
    echo "═══════════════════════════════════════════════════════════════════════════"
}

# Create backup structure
create_backup_structure() {
    log "${CYAN}" "\n📁 Creating backup directory structure..."
    
    mkdir -p "$BACKUP_DIR"
    touch "$BACKUP_LOG"
    
    log "${GREEN}" "✅ Created backup directory: ${BACKUP_DIR}"
}

# Backup efforts
backup_efforts() {
    log "${CYAN}" "\n📦 Backing up efforts..."
    
    if [ ! -d "$EFFORTS_ROOT" ]; then
        log "${YELLOW}" "⚠️  No efforts directory found. Nothing to backup."
        return
    fi
    
    # Count total efforts
    local total_efforts=$(find "$EFFORTS_ROOT" -type d -name ".git" 2>/dev/null | wc -l)
    log "${BLUE}" "Found ${total_efforts} git repositories to backup"
    
    # Copy entire efforts directory
    log "${BLUE}" "Copying efforts directory..."
    cp -r "$EFFORTS_ROOT" "${BACKUP_DIR}/" 2>&1 | tee -a "$BACKUP_LOG"
    
    # Create manifest
    log "${CYAN}" "\n📝 Creating backup manifest..."
    
    {
        echo "{"
        echo "  \"backup_timestamp\": \"$(date -Iseconds)\","
        echo "  \"backup_name\": \"${BACKUP_NAME}\","
        echo "  \"backup_directory\": \"${BACKUP_DIR}\","
        echo "  \"efforts_backed_up\": ["
        
        local first=true
        find "${BACKUP_DIR}/${EFFORTS_ROOT}" -type d -name ".git" | while read -r git_dir; do
            local effort_dir=$(dirname "$git_dir")
            local effort_name=$(basename "$effort_dir")
            local rel_path=${effort_dir#${BACKUP_DIR}/}
            
            cd "$effort_dir"
            local branch=$(git branch --show-current 2>/dev/null || echo "unknown")
            local last_commit=$(git rev-parse HEAD 2>/dev/null || echo "none")
            local has_changes=$(git status --porcelain 2>/dev/null | wc -l)
            cd - > /dev/null
            
            if [ "$first" = true ]; then
                echo -n "    {"
                first=false
            else
                echo ","
                echo -n "    {"
            fi
            
            echo -n "\"name\": \"${effort_name}\", "
            echo -n "\"path\": \"${rel_path}\", "
            echo -n "\"branch\": \"${branch}\", "
            echo -n "\"last_commit\": \"${last_commit}\", "
            echo -n "\"uncommitted_changes\": ${has_changes}}"
        done
        
        echo ""
        echo "  ],"
        echo "  \"total_size\": \"$(du -sh "${BACKUP_DIR}/${EFFORTS_ROOT}" 2>/dev/null | cut -f1)\""
        echo "}"
    } > "$MANIFEST_FILE"
    
    log "${GREEN}" "✅ Backup manifest created: ${MANIFEST_FILE}"
}

# Create restoration script
create_restoration_script() {
    log "${CYAN}" "\n🔧 Creating restoration script..."
    
    local restore_script="${BACKUP_DIR}/restore-backup.sh"
    
    cat > "$restore_script" << 'RESTORE_SCRIPT'
#!/bin/bash

# Restoration script for effort backup
# Auto-generated by backup-all-efforts.sh

set -e

echo "═══════════════════════════════════════════════════════════════════════════"
echo "🔄 RESTORING EFFORT BACKUP"
echo "═══════════════════════════════════════════════════════════════════════════"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TARGET_DIR="${1:-../..}"

echo "Backup directory: $SCRIPT_DIR"
echo "Target directory: $TARGET_DIR"
echo ""

read -p "This will restore efforts to $TARGET_DIR. Continue? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "Restoration cancelled."
    exit 1
fi

# Check if efforts already exist
if [ -d "$TARGET_DIR/efforts" ]; then
    echo "⚠️  Warning: efforts directory already exists in target!"
    read -p "Backup existing efforts first? (Y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Nn]$ ]]; then
        backup_name="pre-restore-$(date +%Y%m%d-%H%M%S)"
        echo "Creating backup: efforts-backup-$backup_name"
        mv "$TARGET_DIR/efforts" "$TARGET_DIR/efforts-backup-$backup_name"
    fi
fi

# Restore efforts
echo "Restoring efforts..."
cp -r "$SCRIPT_DIR/efforts" "$TARGET_DIR/"

echo "✅ Restoration complete!"
echo ""
echo "Restored efforts are in: $TARGET_DIR/efforts"
echo "Review the backup manifest for details: $SCRIPT_DIR/backup-manifest.json"
RESTORE_SCRIPT
    
    chmod +x "$restore_script"
    log "${GREEN}" "✅ Restoration script created: ${restore_script}"
}

# Optional compression
compress_backup() {
    log "${CYAN}" "\n🗜️  Compressing backup..."
    
    read -p "Compress backup for storage? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        local archive_name="${BACKUP_DIR}.tar.gz"
        log "${BLUE}" "Creating archive: ${archive_name}"
        
        tar -czf "$archive_name" "$BACKUP_DIR" 2>&1 | tee -a "$BACKUP_LOG"
        
        local archive_size=$(du -h "$archive_name" | cut -f1)
        log "${GREEN}" "✅ Archive created: ${archive_name} (${archive_size})"
        
        read -p "Remove uncompressed backup? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            rm -rf "$BACKUP_DIR"
            log "${GREEN}" "✅ Uncompressed backup removed"
        fi
    fi
}

# Generate summary
generate_summary() {
    log "${BOLD}${CYAN}" "\n═══════════════════════════════════════════════════════════════════════════"
    log "${BOLD}${CYAN}" "📊 BACKUP SUMMARY"
    log "${BOLD}${CYAN}" "═══════════════════════════════════════════════════════════════════════════"
    
    if [ -d "$BACKUP_DIR" ]; then
        local backup_size=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1)
        local effort_count=$(find "${BACKUP_DIR}/${EFFORTS_ROOT}" -type d -name ".git" 2>/dev/null | wc -l)
        
        log "${GREEN}" "✅ Backup completed successfully"
        log "${BLUE}" "📁 Backup location: ${BACKUP_DIR}"
        log "${BLUE}" "📊 Total efforts backed up: ${effort_count}"
        log "${BLUE}" "💾 Backup size: ${backup_size}"
        log "${BLUE}" "📝 Manifest: ${MANIFEST_FILE}"
        log "${BLUE}" "🔧 Restoration script: ${BACKUP_DIR}/restore-backup.sh"
    fi
    
    if [ -f "${BACKUP_DIR}.tar.gz" ]; then
        local archive_size=$(du -h "${BACKUP_DIR}.tar.gz" | cut -f1)
        log "${BLUE}" "🗜️  Compressed archive: ${BACKUP_DIR}.tar.gz (${archive_size})"
    fi
    
    log "${CYAN}" "\n⏰ Completed at: $(date '+%Y-%m-%d %H:%M:%S %Z')"
}

# Main execution
main() {
    print_header
    create_backup_structure
    backup_efforts
    create_restoration_script
    compress_backup
    generate_summary
}

# Help function
show_help() {
    cat << EOF
═══════════════════════════════════════════════════════════════════════════
🏭 SOFTWARE FACTORY 2.0 - EFFORT BACKUP UTILITY
═══════════════════════════════════════════════════════════════════════════

USAGE:
    $0 [backup-name]

DESCRIPTION:
    Creates a complete backup of all effort directories preserving their
    git state, uncommitted changes, and directory structure.

ARGUMENTS:
    backup-name    Optional name for the backup (default: "backup")
                  The actual directory will be: efforts-{name}-{timestamp}

EXAMPLES:
    # Basic backup
    $0

    # Named backup before integration
    $0 pre-integration

    # Named backup before phase transition
    $0 phase1-complete

FEATURES:
    • Complete directory structure preservation
    • Git state preservation (branches, commits, uncommitted changes)
    • Backup manifest with metadata
    • Auto-generated restoration script
    • Optional compression for storage
    • Timestamped backups prevent overwrites

OUTPUT:
    • backups/efforts-{name}-{timestamp}/ - Backup directory
    • backup-manifest.json - Detailed backup metadata
    • restore-backup.sh - Restoration script
    • backup.log - Backup operation log
    • Optional: .tar.gz compressed archive

═══════════════════════════════════════════════════════════════════════════
EOF
}

# Parse command line arguments
if [ "$#" -gt 0 ] && [[ "$1" == "-h" || "$1" == "--help" || "$1" == "help" ]]; then
    show_help
    exit 0
fi

# Run main function
main "$@"